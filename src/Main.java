import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Main {

	public static void main(String[] args) throws IOException, InterruptedException {

		String inputFilePath = "C:\\Users\\pandu.wicaksono91\\Documents\\GitHub\\external-memory-merge-sort\\Merge Input\\";
		String outputFilePath = "C:\\Users\\pandu.wicaksono91\\Documents\\GitHub\\external-memory-merge-sort\\Merge Output\\";

		// String inputFilePath = "E:\\Merge Input\\";
		// //"C:\\Users\\pandu.wicaksono91\\Documents\\GitHub\\external-memory-merge-sort\\Merge
		// Input\\";
		// String outputFilePath = "E:\\Merge
		// Output\\";//"C:\\Users\\pandu.wicaksono91\\Documents\\GitHub\\external-memory-merge-sort\\Merge
		// Output\\";

		boolean isGenerateFile = true; // generate new file or use the existing
										// one
		boolean debug = false; // print normal file with readable int
		List<String> listResult = new ArrayList<String>();// result list
															// generated by
															// merge sort
		List<String> listResultH = new ArrayList<String>();// result list
															// generated by heap
															// sort

		int M = 250000;
		int d = 64;
		int N = 32000000;
		int B = 32768;
		int nn = 10;

		int Narray[] = { 15625, 31250, 62500, 125000, 250000, 500000, 1000000, 2000000, 4000000, 8000000, 16000000,
				32000000 };

		// generate the files for testing for the first time the experiment is performed
		// to generate, set the isGenerateFile variable above into true
		// set isGenerateFile to false to skip generating files
		if (isGenerateFile) {
			for (int nTest : Narray) {
				FileGenerator generator = new FileGenerator(nTest, inputFilePath, "input" + nTest + ".data");
				generator.generateFile();
			}
		}

		// 3.2.1.1 for small input
		// B = 8,388,608; M = 250,000; d = 2
		// increase the number of N
		M = 250000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of N using M=" + M + " d=" + d + " b=" + B);
		for (int ii = 0; ii <= 7; ii++) {
			String inputFileName = "input" + Narray[ii] + ".data";
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d,
					Narray[ii], B, nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements="
					+ Narray[ii] + " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}

		// 3.2.1.2 for large input
		// B = 8,388,608; M = 250,000; d = 2
		// increase the number of N
		M = 250000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of N using M=" + M + " d=" + d + " b=" + B);
		for (int ii = 8; ii <= 11; ii++) {
			String inputFileName = "input" + Narray[ii] + ".data";
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d,
					Narray[ii], B, nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements="
					+ Narray[ii] + " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}

		// 3.2.2.1 for small input
		// N = 2,000,000; B = 8,388,608; d = 2
		// increase the number of M
		N = 2000000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of M using N=" + N + " d=" + d + " b=" + B);
		for (int ii = 0; ii <= 8; ii++) {
			String inputFileName = "input" + N + ".data";
			M = Narray[ii];
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d, N, B,
					nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements=" + N
					+ " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}

		// 3.2.2.2 for large input
		// N = 32,000,000; B = 8,388,608; d = 2
		// increase the number of M
		N = 32000000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of M using N=" + N + " d=" + d + " b=" + B);
		for (int ii = 0; ii <= 11; ii++) {
			String inputFileName = "input" + N + ".data";
			M = Narray[ii];
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d, N, B,
					nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements=" + N
					+ " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			// listResult.add(str);
		}

		// 3.2.3.1 for small input
		// N = 2,000,000; B = 8,388,608; M = 250,000
		// increase the number of d
		N = 2000000;
		M = 250000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of d using N=" + N + " M=" + M + " b=" + B);
		for (int ii = 1; ii <= 3; ii++) {
			int currD = (int) Math.pow(d, ii);
			String inputFileName = "input" + N + ".data";
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, currD,
					N, B, nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + currD + " Nelements="
					+ N + " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}

		// 3.2.3.2 for large input
		// N = 32,000,000; B = 8,388,608; M = 250,000
		// increase the number of d
		N = 32000000;
		M = 250000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of d using N=" + N + " M=" + M + " b=" + B);
		for (int ii = 1; ii <= 7; ii++) {
			int currD = (int) Math.pow(d, ii);
			String inputFileName = "input" + N + ".data";
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, currD,
					N, B, nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + currD + " Nelements="
					+ N + " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}

		// 3.2.4 Comparison with Main Memory Heapsort using small input
		// B = 8,388,608; M = 2,000,000; d = 2
		// increase the number of N
		M = 2000000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of N using M=" + M + " d=" + d + " b=" + B);
		for (int ii = 0; ii <= 7; ii++) {
			String inputFileName = "input" + Narray[ii] + ".data";
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d,
					Narray[ii], B, nn);
			long resultM[] = mergeSort.run();

			String strM = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements="
					+ Narray[ii] + " times=" + nn + "(in SystemTime & UserTime);" + resultM[0] + ";" + resultM[1];
			System.out.println(strM);
			listResult.add(strM);
		}

		for (int ii = 0; ii <= 7; ii++) {
			String inputFileName = "input" + Narray[ii] + ".data";
			HeapSortTest heapSort = new HeapSortTest(inputFilePath, outputFilePath, inputFileName, debug, B, nn);
			long resultH[] = heapSort.run();

			String strH = "Average time for Heap sort with Nelements=" + Narray[ii] + " times=" + nn
					+ "(in SystemTime & UserTime);" + resultH[0] + ";" + resultH[1];
			System.out.println(strH);
			listResultH.add(strH);
		}

		// 3.2.4 Comparison with Main Memory Heapsort using large input
		// B = 8,388,608; M = 32,000,000; d = 2
		// increase the number of N
		M = 32000000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of N using M=" + M + " d=" + d + " b=" + B);
		for (int ii = 8; ii <= 11; ii++) {
			String inputFileName = "input" + Narray[ii] + ".data";
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d,
					Narray[ii], B, nn);
			long resultM[] = mergeSort.run();

			String strM = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements="
					+ Narray[ii] + " times=" + nn + "(in SystemTime & UserTime);" + resultM[0] + ";" + resultM[1];
			System.out.println(strM);
			listResult.add(strM);
		}

		for (int ii = 8; ii <= 11; ii++) {
			String inputFileName = "input" + Narray[ii] + ".data";
			HeapSortTest heapSort = new HeapSortTest(inputFilePath, outputFilePath, inputFileName, debug, B, nn);
			long resultH[] = heapSort.run();

			String strH = "Average time for Heap sort with Nelements=" + Narray[ii] + " times=" + nn
					+ "(in SystemTime & UserTime);" + resultH[0] + ";" + resultH[1];
			System.out.println(strH);
			listResultH.add(strH);
		}

		// 3.2.5.1 Finding the Best Combination of M and d using small input
		// N = 2,000,000; B = 8,388,608; d=2
		// increase the number of M
		// reuse the result of M testing
		
		N = 32000000;
		d = 2;
		B = 8388608;
		System.out.println("Increase the number of M using N=" + N + " d=" + d + " b=" + B);
		for (int ii = 9; ii <= 11; ii++) {
			String inputFileName = "input" + N + ".data";
			M = Narray[ii];
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d, N, B,
					nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements=" + N
					+ " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}
		
		// N = 2,000,000; B = 8,388,608; d=128
		// increase the number of M
		N = 2000000;
		d = 128;
		B = 8388608;
		System.out.println("Increase the number of M using N=" + N + " d=" + d + " b=" + B);
		for (int ii = 0; ii <= 7; ii++) {
			String inputFileName = "input" + N + ".data";
			M = Narray[ii];
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d, N, B,
					nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements=" + N
					+ " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}

		// 3.2.5.2 Finding the Best Combination of M and d using large input
		// N = 32,000,000; B = 8,388,608; d=2
		// increase the number of M
		// reuse the result from M testing
		
		// N = 32,000,000; B = 8,388,608; d=2,048
		// increase the number of M
		N = 32000000;
		d = 2048;
		B = 8388608;
		System.out.println("Increase the number of M using N=" + N + " d=" + d + " b=" + B);
		for (int ii = 0; ii <= 11; ii++) {
			String inputFileName = "input" + N + ".data";
			M = Narray[ii];
			MergeSortTest mergeSort = new MergeSortTest(inputFilePath, outputFilePath, inputFileName, debug, M, d, N, B,
					nn);
			long result[] = mergeSort.run();

			String str = "Average time for External Multi-way Merge-sort with M=" + M + " d=" + d + " Nelements=" + N
					+ " times=" + nn + "(in SystemTime & UserTime);" + result[0] + ";" + result[1];
			System.out.println(str);
			listResult.add(str);
		}

	}
}
